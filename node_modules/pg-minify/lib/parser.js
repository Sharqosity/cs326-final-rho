<<<<<<< HEAD
'use strict';

var errorLib = require('./error');
var utils = require('./utils');

var PEC = errorLib.parsingErrorCode;

// symbols that need no spaces around them:
var compressors = '.,;:()[]=<>+-*/|!?@#';
=======
const {parsingErrorCode, SQLParsingError} = require('./error');
const {getIndexPos} = require('./utils');

// symbols that need no spaces around them:
const compressors = '.,;:()[]=<>+-*/|!?@#';
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79

////////////////////////////////////////////
// Parses and minimizes a PostgreSQL script.
function minify(sql, options) {

    if (typeof sql !== 'string') {
        throw new TypeError('Input SQL must be a text string.');
    }

<<<<<<< HEAD
    if (options !== undefined && typeof options !== 'object') {
        throw new TypeError('Parameter \'options\' must be an object.');
    }

=======
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
    if (!sql.length) {
        return '';
    }

<<<<<<< HEAD
    var idx = 0, // current index
        result = '', // resulting sql
        len = sql.length, // sql length
        EOL = utils.getEOL(sql), // end-of-line
        space = false, // add a space on the next step
        compress = options && options.compress; // option 'compress'

    do {
        var s = sql[idx], // current symbol;
            s1 = idx < len - 1 ? sql[idx + 1] : ''; // next symbol;
=======
    sql = sql.replace(/\r\n/g, '\n');

    options = options || {};

    let idx = 0, // current index
        result = '', // resulting sql
        space = false; // add a space on the next step

    const len = sql.length;

    do {
        const s = sql[idx], // current symbol;
            s1 = sql[idx + 1]; // next symbol;
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79

        if (isGap(s)) {
            while (++idx < len && isGap(sql[idx])) ;
            if (idx < len) {
                space = true;
            }
            idx--;
            continue;
        }

        if (s === '-' && s1 === '-') {
<<<<<<< HEAD
            var lb = sql.indexOf(EOL, idx + 2);
=======
            const lb = sql.indexOf('\n', idx + 2);
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
            if (lb < 0) {
                break;
            }
            idx = lb - 1;
            skipGaps();
            continue;
        }

        if (s === '/' && s1 === '*') {
<<<<<<< HEAD
            var end = sql.indexOf('*/', idx + 2);
            if (end < 0) {
                throwError(PEC.unclosedMLC);
            }
            idx = end + 1;
=======
            let c = idx + 1, open = 0, close = 0, lastOpen, lastClose;
            while (++c < len - 1 && close <= open) {
                if (sql[c] === '/' && sql[c + 1] === '*') {
                    lastOpen = c;
                    open++;
                    c++;
                } else {
                    if (sql[c] === '*' && sql[c + 1] === '/') {
                        lastClose = c;
                        close++;
                        c++;
                    }
                }
            }
            if (close <= open) {
                idx = lastOpen;
                throwError(parsingErrorCode.unclosedMLC);
            }
            if (sql[idx + 2] === '!' && !options.removeAll) {
                if (options.compress) {
                    space = false;
                }
                addSpace();
                result += sql.substring(idx, lastClose + 2)
                    .replace(/\n/g, '\r\n');
            }
            idx = lastClose + 1;
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
            skipGaps();
            continue;
        }

<<<<<<< HEAD
        var closeIdx, text;
=======
        let closeIdx, text;
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79

        if (s === '"') {
            closeIdx = sql.indexOf('"', idx + 1);
            if (closeIdx < 0) {
<<<<<<< HEAD
                throwError(PEC.unclosedQI);
            }
            text = sql.substr(idx, closeIdx - idx + 1);
            if (text.indexOf(EOL) > 0) {
                throwError(PEC.multiLineQI);
            }
            if (compress) {
=======
                throwError(parsingErrorCode.unclosedQI);
            }
            text = sql.substring(idx, closeIdx + 1);
            if (text.indexOf('\n') > 0) {
                throwError(parsingErrorCode.multiLineQI);
            }
            if (options.compress) {
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
                space = false;
            }
            addSpace();
            result += text;
            idx = closeIdx;
            skipGaps();
            continue;
        }

<<<<<<< HEAD
        if (s === '\'') {
            closeIdx = idx;
            do {
                closeIdx = sql.indexOf('\'', closeIdx + 1);
                if (closeIdx > 0) {
                    var step = closeIdx;
                    while (++step < len && sql[step] === '\'') ;
                    if ((step - closeIdx) % 2) {
                        closeIdx = step - 1;
                        break;
                    }
                    closeIdx = step === len ? -1 : step;
                }
            } while (closeIdx > 0);
            if (closeIdx < 0) {
                throwError(PEC.unclosedText);
            }
            if (compress) {
                space = false;
            }
            addSpace();
            text = sql.substr(idx, closeIdx - idx + 1);
            var hasLB = text.indexOf(EOL) > 0;
            if (hasLB) {
                text = text.split(EOL).map(function (m) {
                    return m.replace(/^\s+|\s+$/g, '');
                }).join('\\n');
            }
            var hasTabs = text.indexOf('\t') > 0;
            if (hasLB || hasTabs) {
                var prev = idx ? sql[idx - 1] : '';
                if (prev !== 'E' && prev !== 'e') {
                    var r = result ? result[result.length - 1] : '';
=======
        if (s === `'`) {
            closeIdx = idx;
            do {
                closeIdx = sql.indexOf(`'`, closeIdx + 1);
                if (closeIdx > 0) {
                    let i = closeIdx;
                    while (sql[--i] === '\\') ;
                    if ((closeIdx - i) % 2) {
                        let step = closeIdx;
                        while (++step < len && sql[step] === `'`) ;
                        if ((step - closeIdx) % 2) {
                            closeIdx = step - 1;
                            break;
                        }
                        closeIdx = step === len ? -1 : step;
                    }
                }
            } while (closeIdx > 0);
            if (closeIdx < 0) {
                throwError(parsingErrorCode.unclosedText);
            }
            if (options.compress) {
                space = false;
            }
            addSpace();
            text = sql.substring(idx, closeIdx + 1);
            const hasLB = text.indexOf('\n') > 0;
            if (hasLB) {
                text = text.split('\n').map(m => {
                    return m.replace(/^\s+|\s+$/g, '');
                }).join('\\n');
            }
            const hasTabs = text.indexOf('\t') > 0;
            if (hasLB || hasTabs) {
                const prev = idx ? sql[idx - 1] : '';
                if (prev !== 'E' && prev !== 'e') {
                    const r = result ? result[result.length - 1] : '';
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
                    if (r && r !== ' ' && compressors.indexOf(r) < 0) {
                        result += ' ';
                    }
                    result += 'E';
                }
                if (hasTabs) {
                    text = text.replace(/\t/g, '\\t');
                }
            }
            result += text;
            idx = closeIdx;
            skipGaps();
            continue;
        }

<<<<<<< HEAD
        if (compress && compressors.indexOf(s) >= 0) {
=======
        if (options.compress && compressors.indexOf(s) >= 0) {
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
            space = false;
            skipGaps();
        }

        addSpace();
        result += s;

    } while (++idx < len);

    return result;

    function skipGaps() {
<<<<<<< HEAD
        if (compress) {
            while (idx < len - 1 && isGap(sql[idx + 1])) {
                idx++;
            }
=======
        if (options.compress) {
            while (idx < len - 1 && isGap(sql[idx + 1]) && idx++) ;
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
        }
    }

    function addSpace() {
        if (space) {
            if (result.length) {
                result += ' ';
            }
            space = false;
        }
    }

    function throwError(code) {
<<<<<<< HEAD
        var position = utils.getIndexPos(sql, idx, EOL);
        throw new errorLib.SQLParsingError(code, position);
=======
        const position = getIndexPos(sql, idx);
        throw new SQLParsingError(code, position);
>>>>>>> 104b65a6409f9d6ba105288e6952992f9f09ce79
    }
}

////////////////////////////////////
// Identifies a gap / empty symbol.
function isGap(s) {
    return s === ' ' || s === '\t' || s === '\r' || s === '\n';
}

module.exports = minify;
